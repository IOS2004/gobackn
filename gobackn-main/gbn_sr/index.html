<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Go-back-N Protocol</title>
	<meta http-equiv="X-UA-Compatible" content="IE=Edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" type="text/css" media="screen" href="../global/css/style.css" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@400;700&display=swap" rel="stylesheet">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link
		href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@400;700&family=Victor+Mono:ital,wght@0,100..700;1,100..700&display=swap"
		rel="stylesheet">
	<link rel="stylesheet" type="text/css" media="screen"
		href="../global/css/jqui-lightness/jquery-ui-1.8.18.custom.css" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link
		href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Condensed:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap"
		rel="stylesheet">
	<style type="text/css">
		.ibm-plex-sans-condensed-thin {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 100;
			font-style: normal;
		}

		.ibm-plex-sans-condensed-extralight {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 200;
			font-style: normal;
		}

		.ibm-plex-sans-condensed-light {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 300;
			font-style: normal;
		}

		.ibm-plex-sans-condensed-regular {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 400;
			font-style: normal;
		}

		.ibm-plex-sans-condensed-medium {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 500;
			font-style: normal;
		}

		.ibm-plex-sans-condensed-semibold {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 600;
			font-style: normal;
		}

		.ibm-plex-sans-condensed-bold {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 700;
			font-style: normal;
		}

		.ibm-plex-sans-condensed-thin-italic {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 100;
			font-style: italic;
		}

		.ibm-plex-sans-condensed-extralight-italic {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 200;
			font-style: italic;
		}

		.ibm-plex-sans-condensed-light-italic {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 300;
			font-style: italic;
		}

		.ibm-plex-sans-condensed-regular-italic {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 400;
			font-style: italic;
		}

		.ibm-plex-sans-condensed-medium-italic {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 500;
			font-style: italic;
		}

		.ibm-plex-sans-condensed-semibold-italic {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 600;
			font-style: italic;
		}

		.ibm-plex-sans-condensed-bold-italic {
			font-family: "IBM Plex Sans Condensed", sans-serif;
			font-weight: 700;
			font-style: italic;
		}

		.victor-mono {
			font-family: "Victor Mono", monospace;
			font-optical-sizing: auto;
			font-weight: 500;
			font-style: normal;
		}

		:root {
			/* Light Mode Colors - Enhanced with better contrast */
			--primary-color: #0062b0;
			/* Deeper blue for better visibility */
			--sidebar-width: 400px;
			--sidebar-bg: #f0f4f8;
			/* Keep existing sidebar tone */
			--border-color: #a4b5c6;
			/* Darker borders for definition */
			--shadow-color: rgba(0, 0, 0, 0.15);
			--text-color: #1a2a36;
			/* Keep existing text color */
			--header-bg: #e3f2fd;
			--body-bg: #ffffff;
			--input-bg: #ffffff;
			--input-border: #8ca3b8;
			/* Slightly darker for better definition */
			--button-bg: var(--primary-color);
			--button-text: #ffffff;
			--button-hover-bg: #005b96;
			--tooltip-bg: #344955;
			--tooltip-text: #fff;
			--tooltip-info-bg: #e9ecef;
			--log-bg: #ffffff;
			--log-border: var(--border-color);
			--log-even-row-bg: #f5f9fc;

			/* More saturated packet colors for better distinction */
			--packet-default-bg: #90caf9;
			/* Brighter blue */
			--packet-default-border: #1976d2;
			--packet-default-text: #0d47a1;
			--packet-delivered-bg: #ce93d8;
			/* Richer purple */
			--packet-delivered-border: #8e24aa;
			--packet-delivered-text: #4a148c;
			--packet-confirmed-bg: #ffe082;
			/* Brighter amber */
			--packet-confirmed-border: #ffa000;
			--packet-confirmed-text: #e65100;
			--packet-ack-bg: #a5d6a7;
			/* Richer green */
			--packet-ack-border: #2e7d32;
			--packet-ack-text: #1b5e20;
			--packet-nack-bg: #ef9a9a;
			/* Brighter red */
			--packet-nack-border: #c62828;
			--packet-nack-text: #b71c1c;
			--packet-empty-bg: #cfd8dc;
			/* Distinct gray - not washed out */
			--packet-empty-border: #607d8b;
			--packet-empty-text: #37474f;
			--window-bg: #bbdefb;
			--window-border: #1976d2;
			--sim-bg: #f7fafc;
			/* Keep all other variables the same */

			/* Added previously */
			--tab-bg: var(--sidebar-bg);
			--tab-active-bg: var(--body-bg);
			--tab-border: var(--border-color);
			--tab-active-border: var(--primary-color);
			/* Scrollbar Colors - Light Mode */
			--scrollbar-track-bg: #f1f1f1;
			--scrollbar-thumb-bg: #90a4ae;
			--scrollbar-thumb-hover-bg: #546e7a;
			--scrollbar-thumb-border: var(--border-color);
			--heading-color: #0329d3;
		}

		.amatic-sc-regular {
			font-family: "Amatic SC", sans-serif;
			font-weight: 100;
			font-style: normal;
		}

		.amatic-sc-bold {
			font-family: "Amatic SC", sans-serif;
			font-weight: 900;
			font-style: normal;

		}

		body.dark-mode {
			/* Dark Mode Colors - Enhanced and Darkened */
			--primary-color: #00a2ff;
			--heading-color: #00a2ff;
			/* Brighter, more saturated blue for better visibility on dark */
			--sidebar-bg: #1a1d21;
			/* Much darker sidebar */
			--border-color: #3d4852;
			/* Darker, more subtle borders */
			--shadow-color: rgba(0, 0, 0, 0.5);
			/* Increased shadow opacity */
			--text-color: #ffffff;
			/* Pure white text for maximum contrast */
			--header-bg: #0d1117;
			/* Very dark header */
			--body-bg: #0d1117;
			/* Very dark body background, GitHub dark theme inspired */
			--input-bg: #21262d;
			/* Darker input fields */
			--input-border: #30363d;
			/* Darker, more subtle input borders */
			--button-bg: var(--primary-color);
			--button-text: #ffffff;
			--button-hover-bg: #1f6feb;
			/* Rich blue hover */
			--tooltip-bg: #f0f6fc;
			--tooltip-text: #0d1117;
			--tooltip-info-bg: #21262d;
			--log-bg: #161b22;
			/* Slightly lighter than body bg for contrast */
			--log-border: var(--border-color);
			--log-even-row-bg: #1c2127;
			/* Very subtle contrast for alternating rows */
			--packet-default-bg: #0d4a7f;
			/* Darker blue */
			--packet-default-border: #1a6bae;
			--packet-default-text: #e3f2fd;
			--packet-delivered-bg: #5b1178;
			/* Darker purple */
			--packet-delivered-border: #7b1fa2;
			--packet-delivered-text: #f5e9ff;
			--packet-confirmed-bg: #b26000;
			/* Darker amber */
			--packet-confirmed-border: #e67700;
			--packet-confirmed-text: #fff4de;
			--packet-ack-bg: #215732;
			/* Darker green */
			--packet-ack-border: #2e7d32;
			--packet-ack-text: #e6f5ec;
			--packet-nack-bg: #911c1c;
			/* Darker red */
			--packet-nack-border: #cf222e;
			--packet-nack-text: #ffeded;
			--packet-empty-bg: #21262d;
			--packet-empty-border: #30363d;
			--packet-empty-text: #8b949e;
			--window-bg: #21262d;
			--window-border: #444c56;
			--sim-bg: #161b22;
			/* Added */
			--tab-bg: var(--sidebar-bg);
			--tab-active-bg: var(--body-bg);
			--tab-border: var(--border-color);
			--tab-active-border: var(--primary-color);
			/* Scrollbar Colors - Dark Mode */
			--scrollbar-track-bg: var(--body-bg);
			--scrollbar-thumb-bg: #30363d;
			--scrollbar-thumb-hover-bg: #444c56;
			--scrollbar-thumb-border: var(--input-bg);
		}

		/* Ensure "No data received yet" legend item has sufficient contrast */
		body:not(.dark-mode) .dscPkg.empty-legend {
			color: #37474f;
			/* Darker text */
			border: 1px dashed #607d8b;
			/* More visible border */
			background-color: #eceff1;
			/* Less washed out background */
		}

		/* Also update this for dark mode empty packages */
		body.dark-mode .pkg.empty {
			color: #b0bec5;
			/* Better visibility for empty package text */
			border: 1px dashed #78909c;
			/* More visible dashed border */
		}

		/* Enhance button hover styles for better interaction feedback */
		input[type="button"]:hover {
			background: var(--button-hover-bg);
			box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
		}

		/* Add subtle transition to packet colors for smoother visual experience */
		.pkg {
			transition: background-color 0.2s, border-color 0.2s, color 0.2s;
		}

		/* Improve tooltip visibility */
		.tooltip .tooltiptext,
		.tooltip .tooltiptext1 {
			box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
		}

		body {
			margin: 0;
			padding: 0;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
			display: flex;
			flex-direction: column;
			min-height: 100vh;
			background-color: var(--body-bg);
			color: var(--text-color);
			overflow-x: hidden;
		}

		/* Header styles */
		header {
			background: var(--header-bg);
			color: var(--primary-color);
			padding: 1rem;
			text-align: center;
			box-shadow: 0 2px 4px var(--shadow-color);
			position: relative;
			z-index: 10;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		header h1 {
			margin: 0;
			flex-grow: 1;
			text-align: center;
		}

		#theme-toggle img {
			width: 20px;
			height: 20px;
		}

		body.dark-mode #theme-toggle {
			border-color: var(--text-color);
			color: var(--text-color);
		}

		/* Main container */
		.container {
			display: flex;
			flex: 1;
			position: relative;
			overflow: hidden;
		}

		/* Sidebar */
		#sidebar {
			width: var(--sidebar-width);
			background: var(--sidebar-bg);
			border-right: 1px solid var(--border-color);
			transition: transform 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
			overflow-y: auto;
			overflow-x: visible;
			position: fixed;
			top: 0;
			bottom: 0;
			left: 0;
			z-index: 100;
			height: 100vh;
			box-shadow: 2px 0 5px var(--shadow-color);
		}

		#theme-toggle {
			position: absolute;
			top: 10px;
			right: 10px;
			background: var(--primary-color);
			color: white;
			border: none;
			border-radius: 4px;
			padding: 5px 10px;
			cursor: pointer;
		}

		#sidebar.closed {
			transform: translateX(calc(-1 * var(--sidebar-width)));
		}

		/* Toggle button */
		#sidebar-toggle {
			position: fixed;
			left: var(--sidebar-width);
			/* top: 15px; */
			/* Change this line */
			top: 10px;
			/* Adjust this value as needed (e.g., 8px, 10px, 12px) */
			z-index: 101;
			background: var(--primary-color);
			color: white;
			border: none;
			border-radius: 0 4px 4px 0;
			padding: 10px;
			cursor: pointer;
			box-shadow: 2px 0 5px var(--shadow-color);
			transition: left 0.3s ease;
		}

		#sidebar-toggle.closed {
			left: 2px;
		}

		/* Main content */
		#main-content {
			flex: 1;
			padding: 1rem;
			margin-left: var(--sidebar-width);
			transition: margin-left 0.3s ease;
			width: calc(100% - var(--sidebar-width));
			background-color: var(--body-bg);
		}

		#main-content.expanded {
			margin-left: 0;
			width: 100%;
		}

		/* --- FIX for External CSS Override --- */
		/* Apply dark mode styles to the config/legend panels */
		body.dark-mode .config,
		body.dark-mode .legend,
		body.dark-mode .def {
			background-color: var(--sidebar-bg);
			/* Use the sidebar's dark background */
			border-color: var(--border-color);
			/* Use the dark mode border color */
			color: var(--text-color);
			/* Use the default dark mode text color */
		}

		/* Ensure headings inside these panels also use dark mode colors */
		body.dark-mode .config h3,
		body.dark-mode .legend h2,
		/* Legend uses h2 */
		body.dark-mode .def h3 {
			/* Assuming .def might use h3 */
			color: var(--primary-color);
			/* Match heading color from index.html */
			border-bottom-color: var(--border-color);
			/* Adjust separator lines if they exist */
		}

		/* Ensure labels/subheadings inside use dark mode text color */
		body.dark-mode .config h5,
		body.dark-mode .config label {
			color: var(--text-color);
		}

		/* Ensure description text inside uses dark mode text color */
		body.dark-mode .config .description {
			color: #adb5bd;
			/* A slightly lighter grey for descriptions, matching legend text */
		}

		/* Ensure table headers in legend are styled for dark mode */
		body.dark-mode .legend th {
			background-color: var(--input-bg);
			/* Use a dark background */
			border-color: var(--border-color);
			color: var(--text-color);
		}

		/* Ensure table data cells in legend use appropriate colors */
		body.dark-mode .legend td {
			border-color: var(--border-color);
			color: var(--text-color);
		}

		/* --- End of FIX --- */
		/* Tabs in sidebar */
		.tab-container {
			border-bottom: 1px solid var(--border-color);
		}

		.tab-buttons {
			display: flex;
			background: var(--tab-bg);
			border-bottom: 1px solid var(--tab-border);

		}

		.tab-button {
			flex: 1;
			padding: 10px;
			text-align: center;
			background: var(--tab-bg);
			color: var(--text-color);
			border: none;
			cursor: pointer;
			font-weight: 500;
			transition: background-color 0.2s ease, color 0.2s ease;
		}

		.tab-button.active {
			background: var(--tab-active-bg);
			border-bottom: 3px solid var(--tab-active-border);
			font-weight: 600;
			color: var(--primary-color);
		}

		body.dark-mode .tab-button.active {
			background: var(--body-bg);
			border-bottom: 3px solid var(--primary-color);
			font-weight: 700;
			color: var(--primary-color);
		}

		.tab-content {
			display: none;
			padding: 0.5rem;
		}

		.tab-content.active {
			display: block;
		}

		/* Forms and inputs */
		.form-item {
			margin-bottom: 1rem;
			padding: 0.5rem;
			border-bottom: 1px solid var(--border-color);
		}

		.form-item h3 {
			margin-top: 0;
			font-size: 1rem;
			color: var(--primary-color);
		}

		.form-item h5 {
			margin: 0.5rem 0;
			font-size: 0.9rem;
		}

		input[type="number"],
		input[type="button"],
		select {
			padding: 5px;
			border: 1px solid var(--input-border);
			background-color: var(--input-bg);
			color: var(--text-color);
			border-radius: 3px;
			margin: 2px 0;
			transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
		}

		body.dark-mode input[type="number"],
		body.dark-mode select {
			background-color: var(--input-bg);
			color: var (--text-color);
			border-color: var(--input-border);
		}

		input[type="button"] {
			background: var(--button-bg);
			color: var(--button-text);
			cursor: pointer;
			padding: 8px 15px;
			border: none;
			border-radius: 4px;
			transition: background-color 0.3s ease, border-color 0.3s ease;
			margin-right: 5px;
		}

		input[type="button"]:hover {
			background: var(--button-hover-bg);
		}

		/* --- FIX for Input Field Contrast in Dark Mode --- */

		/* Style ENABLED inputs within .config in dark mode */
		body.dark-mode .config input[type=number] {
			background-color: var(--input-bg);
			/* Apply dark background */
			color: var(--text-color);
			/* Apply light text */
			border-color: var(--input-border);
			/* Apply dark border */
		}

		/* Style DISABLED inputs within .config in dark mode */
		/* Overrides both external styles and the more generic dark mode disabled rule */
		body.dark-mode .config input[type=number]:disabled {
			background-color: #161b22;
			/* Specific dark disabled background */
			color: #6e7681;
			/* Slightly lighter grey text for better contrast */
			border-color: #30363d;
			/* Specific dark disabled border */
			opacity: 0.8;
			/* Keep the opacity effect */
			cursor: not-allowed;
		}

		/* Also ensure the disabled unit selects have appropriate colors */
		body.dark-mode .config .unitdisabled {
			background-color: #161b22;
			/* Match disabled input background */
			color: #6e7681;
			/* Match disabled input text */
			border-color: #30363d;
			/* Match disabled input border */
			border-left: none;
			/* Keep left border removed */
		}

		/* --- End of FIX --- */
		/* --- FIX for Legend Text Contrast in Light Mode --- */
		/* Darken the text for the "No data" legend item in light mode */
		body:not(.dark-mode) .dscPkg.empty-legend {
			color: #37474f;
			/* Darker text */
			border: 1px dashed #607d8b;
			/* More visible border */
			background-color: #eceff1;
			/* Less washed out background */
		}

		/* --- End of FIX --- */
		/* Legend */
		.legend {
			padding: 0.5rem;
		}

		.legend h2 {
			margin-top: 0;
			font-size: 1.2rem;
			color: var(--primary-color);
		}

		.legend table {
			width: 100%;
			border-collapse: collapse;
		}

		.legend td {
			padding: 5px;
		}

		/* Info text */
		.legend p {
			font-size: 0.8rem;
			color: #6c757d;
			margin: 5px 0;
		}

		/* Simulation area */
		#svg {
			position: relative;
			width: 100%;
			min-height: 420px;
			overflow: hidden;
			padding: 0;
			background-color: var(--sim-bg);
			border: 1px solid var(--border-color);
			border-radius: 4px;
			box-shadow: 0 2px 4px var(--shadow-color);
		}

		#root {
			position: absolute;
			left: 0;
			top: 0;
			width: auto;
			z-index: 1;
			height: 100%;
		}

		#svg>#root div,
		#svg canvas {
			position: absolute;
		}

		/* Lines */
		.lineSender,
		.lineReciever {
			border: none;
			height: 1px;
			background-color: var(--border-color);
			position: absolute;
			z-index: 1;
			width: 100%;
		}

		.lineSender {
			top: 50px;
		}

		.lineReciever {
			bottom: 50px;
		}

		/* Packets */
		div.dscPkg {
			border: 1px solid var(--border-color);
			width: 100%;
			height: 37.6px;
			display: flex;
			align-items: center;
			justify-content: center;
			text-align: center;
			font-size: 12px;
			padding: 5px 8px;
			margin: 0;
			border-radius: 3px;
			color: var(--text-color);
			box-sizing: border-box;
			background-color: var(--input-bg);
		}

		.window {

			border: 2px solid rgb(7, 24, 255);
			background: var(--window-bg);
			z-index: 41;
			border-radius: 2px;
			margin-top: -2px;
			margin-left: -2px;
			padding-right: 2px;
		}

		.pkg {
			font-size: 11px;
			writing-mode: vertical-lr;
			transform: rotate(180deg);
			background: var(--packet-default-bg);
			border: 1px solid var(--packet-default-border);
			width: 18px;
			height: 30px;
			z-index: 42;
			padding: 0;
			margin: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			text-align: center;
			box-sizing: border-box;
			border-radius: 2px;
			color: var(--packet-default-text);
			font-weight: 500;

			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			transition: background-color 0.2s, border-color 0.2s, color 0.2s;
		}

		.pkg.delivered {
			color: var(--packet-delivered-text);
			background: var(--packet-delivered-bg);
			border-color: var(--packet-delivered-border);
		}

		.pkg.confirmed {
			background: var(--packet-confirmed-bg);
			border-color: var(--packet-confirmed-border);
			color: var(--packet-confirmed-text);
		}

		.pkg.ack {
			color: var(--packet-ack-text);
			background: var(--packet-ack-bg);
			border-color: var(--packet-ack-border);
		}

		.pkg.nack {
			color: var(--packet-nack-text);
			background: var(--packet-nack-bg);
			border-color: var(--packet-nack-border);
		}

		.pkg.empty {
			font-size: 11px;
			color: var(--packet-empty-text);
			background: var(--packet-empty-bg);
			border: 1px dashed var(--packet-empty-border);
		}

		body.dark-mode .pkg.empty {
			color: #b0bec5;
			border: 1px dashed #78909c;
		}

		#svg canvas.window-timer {
			height: 40px;
			width: 40px;
			z-index: 45;
			margin-left: -20px;

		}

		/* Tooltip styles */
		.tooltip {
			position: relative;
			display: inline-block;
			cursor: help;
			margin-left: 5px;
			width: 16px;
			height: 16px;

			line-height: 16px;
			text-align: center;
			border-radius: 50%;
			font-size: 12px;
		}

		.tooltip .tooltiptext,
		.tooltip .tooltiptext1 {
			visibility: hidden;
			max-width: 200px;
			width: max-content;
			background-color: var(--tooltip-bg);
			color: var(--tooltip-text);
			text-align: left;
			border-radius: 6px;
			padding: 8px 12px;
			position: absolute;
			z-index: 1000;
			left: 26px;
			top: 50%;
			transform: translateY(-50%);
			margin-left: 0;
			opacity: 0;
			transition: opacity 0.3s;
			font-size: 12px;
			font-weight: normal;
			box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
			pointer-events: none;
			word-wrap: break-word;
		}

		.tooltip .tooltiptext::after,
		.tooltip .tooltiptext1::after {
			content: "";
			position: absolute;
			top: 50%;
			right: 100%;
			margin-top: -5px;
			border-width: 5px;
			border-style: solid;
			border-color: transparent var(--tooltip-bg) transparent transparent;
		}

		body.dark-mode .tooltip .tooltiptext::after,
		body.dark-mode .tooltip .tooltiptext1::after {
			border-color: transparent var(--tooltip-bg) transparent transparent;
		}

		.tooltip:hover .tooltiptext,
		.tooltip:hover .tooltiptext1 {
			visibility: visible;
			opacity: 1;
		}

		#sidebar .form-item:nth-last-child(-n+3) .tooltip .tooltiptext,
		#sidebar .form-item:nth-last-child(-n+3) .tooltip .tooltiptext1 {
			bottom: 0;
			top: auto;
			transform: none;
		}

		#sidebar .form-item:nth-last-child(-n+3) .tooltip .tooltiptext::after,
		#sidebar .form-item:nth-last-child(-n+3) .tooltip .tooltiptext1::after {
			top: 15px;
		}

		/* Log styles */
		#log {
			position: relative;
			overflow: auto;
			width: 100%;
			height: 230px;
			display: block;
			border: 1px solid var(--log-border);
			/* Use variable */
			border-radius: 4px;
			padding: 10px;
			margin-top: 10px;
			background: var(--log-bg);
			/* Use variable */
			max-width: 100%;
			box-sizing: border-box;
			transition: background-color 0.3s ease, border-color 0.3s ease;
			/* Add transitions */
		}

		/* Ensure log background in dark mode */
		body.dark-mode #log {
			background-color: var(--log-bg) !important;
			color: var(--text-color) !important;
			border-color: var(--log-border) !important;
		}

		#myLog {
			white-space: pre-wrap;
			word-wrap: break-word;
			margin: 0;
			font-family: monospace;
			font-size: 14px;
			line-height: 1.5;
			max-width: 100%;
			overflow-x: hidden;
			color: var(--text-color);
			/* Ensure log text color changes */
			transition: color 0.3s ease;
			/* Add transitions */
		}

		/* Ensure log text color in dark mode */
		body.dark-mode #myLog {
			color: var(--text-color) !important;
		}

		/* Add zebra striping to log entries (Increased Specificity) */
		#log #myLog>div:nth-child(even) {
			background-color: var(--log-even-row-bg);
			/* Use variable */
			transition: background-color 0.3s ease;
			/* Add transitions */
		}

		/* Fix dark mode for all inline elements */
		body.dark-mode div.dscPkg,
		body.dark-mode .legend h2,
		body.dark-mode .tooltip,
		body.dark-mode .form-item h3,
		body.dark-mode .form-item h5 {
			color: var(--text-color) !important;
		}

		/* Force background colors for elements that might have inline styles */
		body.dark-mode #svg,
		body.dark-mode .tab-content,
		body.dark-mode .form-item {
			background-color: transparent !important;
		}

		/* Ensure legend items get correct styling */
		body.dark-mode .legend table td div {
			border-color: var(--border-color) !important;
		}

		body.dark-mode .legend p {
			color: #adb5bd !important;
			/* Lighter grey for dark mode */
		}

		/* Responsive adjustments */
		@media (max-width: 768px) {
			:root {
				--sidebar-width: 320px;
			}

			header h1 {
				font-size: 1.5rem;
			}

			.tooltip .tooltiptext,
			.tooltip .tooltiptext1 {
				width: 180px;
				max-width: 180px;
				font-size: 11px;
			}
		}

		@media (max-width: 576px) {
			:root {
				--sidebar-width: 100%;
			}

			#sidebar {
				width: 100%;
			}

			#sidebar-toggle.closed {
				left: 10px;
			}

			#main-content.expanded {
				margin-top: 50px;
			}
		}

		/* Make main section headings bolder and slightly larger */
		.form-item>h3>label {
			font-weight: 600;
			font-size: 1.05rem;
		}

		.form-item>h3 {
			margin-bottom: 1rem;
		}

		/* Style disabled elements */
		input:disabled,
		select:disabled,
		input[type="button"]:disabled {
			opacity: 0.6;
			cursor: not-allowed;
		}

		body.dark-mode select.unitdisabled {
			background-color: var(--input-bg);
			color: var(--text-color);
			border-color: var(--input-border);
		}

		/* Specific dark mode overrides for inputs/selects */
		body.dark-mode input[type="number"],
		body.dark-mode select {
			background-color: var(--input-bg);
			color: var(--text-color);
			border-color: var(--input-border);
		}

		.centreRotate {
			transform: rotate(90deg);
			margin-left: 0px;
			/* Reset margin */
		}

		/* Dark mode specific disabled styles */
		body.dark-mode input:disabled,
		body.dark-mode select:disabled {
			background-color: #161b22;
			color: #6e7681;
			border-color: #30363d;
			opacity: 0.8;
			cursor: not-allowed;
		}

		/* Starry Background */
		.stars-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
			z-index: 0;
			/* Behind simulation elements but above the background */
			pointer-events: none;
			/* Ensure clicks pass through to simulation elements */
		}

		.star {
			position: absolute;
			background-color: rgba(100, 100, 180, 0.7);
			/* Bluish color for light mode */
			border-radius: 50%;
			opacity: 0;
			animation: twinkle 5s infinite ease-in-out;
		}

		body.dark-mode .star {
			background-color: rgba(255, 255, 255, 0.8);
			/* Whiter color for dark mode */
		}

		@keyframes twinkle {
			0% {
				opacity: 0;
			}

			50% {
				opacity: 1;
			}

			100% {
				opacity: 0;
			}
		}

		/* Toggle Switch Styles */
		.toggle-switch {
			position: relative;
			margin-top: 8px;
			display: inline-block;
			width: 35px;
			/* Width of the switch */
			height: 20px;
			/* Height of the switch */
			flex-shrink: 0;
			/* Prevent flexbox from shrinking the switch */
		}

		/* Hide default HTML checkbox */
		.toggle-switch input {
			opacity: 0;
			width: 0;
			height: 0;
			position: absolute;
			/* Take it out of layout flow */
		}

		/* The slider track */
		.slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #ccc;
			/* Track color when OFF */
			-webkit-transition: .4s;
			transition: .4s;
		}

		/* The slider knob */
		.slider:before {
			position: absolute;
			content: "";
			height: 15px;
			width: 15px;
			left: 2.5px;
			/* Start with a bit of padding from the left */
			bottom: 2.5px;
			background-color: white;
			-webkit-transition: .25s ease-in-out;
			transition: .25s ease-in-out;
		}



		/* Change track color when checked */
		input:checked+.slider {
			background-color: var(--primary-color, #007bff);
			/* Use theme color or fallback */
		}

		/* Move knob when checked */

		input:checked+.slider:before {
			-webkit-transform: translateX(15px);
			/* 35 (track width) - 15 (knob width) - 2.5*2 (padding) = 15px */
			-ms-transform: translateX(15px);
			transform: translateX(15px);
		}

		/* Rounded sliders */
		.slider.round {
			border-radius: 24px;
			/* Make track rounded (height) */
		}

		.slider.round:before {
			border-radius: 50%;
			/* Make knob round */
		}

		/* Optional: Adjust tooltip position if needed */
		/* Since it's now in a span next to the switch, default positioning might be okay */

		/* Ensure label text remains clickable (though clicking the switch is primary) */
		label[for="enableNacksCheckbox"] {
			cursor: pointer;
		}

		/* Style the text span if needed */
		span[style*="margin-left"] {
			cursor: default;
			/* Indicate text isn't the primary control */
		}
	</style>
	<script type="text/javascript" src="../global/js/jquery-1.7.1.min.js"></script>
	<script type="text/javascript" src="../global/js/jquery.pause.min.js"></script>
	<script type="text/javascript" src="../global/js/modernizr.js"></script>
	<script type="text/javascript" src="../global/js/global.js"></script>
	<script type="text/javascript" src="../global/js/jquery-ui-1.8.18.custom.min.js"></script>
	<script type="text/javascript">
		/* globals */
		var running = false;
		var display;
		var contr;
		var sender;
		var receiver;
		var typewriter = true;
		var endToEndDelay;
		var TimeoutMin;
		var capacity;
		var length;
		var propagation;
		var dataSize;
		var unitSize;
		var ackSize;
		var ackTT;
		var paper;
		var ctotal = 0;
		var autostop = 1;
		var PDspeedFactor = 0;
		var unitc = 0;
		var numberUI;
		var start;
		var sizecheck;
		var sizecheck1;
		var totaltimef;
		var NACKFlag = false;
		var autoscale = false;
		var overall_time;
		var unlock = false;
		var nacksEnabled = true;

		// Add function to create starry background
		function createStarryBackground() {
			const starsContainer = document.createElement('div');
			starsContainer.className = 'stars-container';

			// Create stars with random positions, sizes and animation delays
			const numStars = 100; // Number of stars to create
			for (let i = 0; i < numStars; i++) {
				const star = document.createElement('div');
				star.className = 'star';

				// Random position
				const left = Math.random() * 100;
				const top = Math.random() * 100;

				// Random size (0.5px to 3px)
				const size = 0.5 + Math.random() * 2.5;

				// Random animation delay and duration
				const delay = Math.random() * 5;
				const duration = 3 + Math.random() * 4;

				// Set star styles
				star.style.left = `${left}%`;
				star.style.top = `${top}%`;
				star.style.width = `${size}px`;
				star.style.height = `${size}px`;
				star.style.animationDelay = `${delay}s`;
				star.style.animationDuration = `${duration}s`;

				starsContainer.appendChild(star);
			}

			// Add to simulation area (prepend to make it the background)
			const simulationArea = document.getElementById('svg');
			simulationArea.prepend(starsContainer);
		}

		const reloadtButton = document.querySelector("#reload");
		// Reload everything:
		function reload() {
			reload = location.reload();
		}


		function logger() {
			var x = document.getElementById("log");
			if (x.style.display === "none") {
				x.style.display = "block";
			} else {
				x.style.display = "none";
			}
		}

		window.console = {
			log: function (str) {
				var node = document.createElement("div");
				node.appendChild(document.createTextNode(str));
				document.getElementById("myLog").appendChild(node);
				// Auto-scroll to the bottom of the log window
				var logContainer = document.getElementById("log");
				logContainer.scrollTop = logContainer.scrollHeight;
			}
		}

		function speedWarning() {

			if (contr.timeBetweenPkgs > 1000000 || contr.timeBetweenPkgs < 0.000001 || endToEndDelay > 1000000 || endToEndDelay < 0.000001 || ackTT > 1000000 || ackTT < 0.000001)
				HideSpeed(true);
			else
				HideSpeed(false);

		}

		function convertRange(value, r1, r2) {
			return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];
		}

		function timedCount() {
			start = Date.now();
		}

		function HideSpeed(hide) {
			var x = document.getElementById("speedfault");
			var y = document.getElementById("speedwarning");
			if (hide) {
				x.style.display = "none";
				y.style.display = "block";
			} else {
				x.style.display = "block";
				y.style.display = "none";
			}
		}


		$(document).ready(function () {
			checkFeatures({
				inlinesvg: false,
				canvas: true
			});

			rangeInputCompability();
		});

		function Controller() {
			this.setNackEnabledState = function (isEnabled) {
				nacksEnabled = isEnabled; // Update the global variable
				console.log("NACKs enabled status set to: " + nacksEnabled);
				// Optional: You might want to re-initialize or clear logs if changing this mid-simulation
				// initAnimation(contr.getMethod()); // Uncomment if you want changing this to reset the simulation
			}
			this.resetConfig = function () {
				this.SetDefaultC(1, 1000);
				this.SetDefaultL(1, 1000);
				this.SetDefaultP(200000, 1000);
				this.SetDefaultD(10, 1000);
				this.SetDefaultU(500, 1);
				this.SetDefaultA(20, 1);
				display.setNsender(5, sender.base);
				sender.N = 5;
				document.getElementById('receiverN').value = 1;
				display.setNreceiver(1, receiver.base);
				receiver.N = 1;
				sender.timeout = 40;
				document.getElementById('senderN').value = 5;
				document.getElementById('timeout').value = 60;
				// **** RESET NACK STATE ****
				document.getElementById('enableNacksCheckbox').checked = true; // Reset checkbox visually
				nacksEnabled = true; // Reset the global variable
				// **** END RESET NACK STATE ****
				document.getElementById('timeout').min = TimeoutMin;
				document.getElementById('TotalTime').value = "";
				document.getElementById('unitTimeout').value = 1;
				initAnimation(contr.getMethod());

			}

			this.getMethod = function () {
				var e = 'gbn';
				return e;
				//return $('input[name=method]:checked').val();
			}

			this.setMethod = function () {
				//	console.log('switch method to '+this.getMethod());
				initAnimation(this.getMethod());
				this.resetConfig()
			}

			this.getSenderN = function () {
				return parseInt(document.getElementById('senderN').value);
			}

			this.getReceiverN = function () {
				return parseInt(document.getElementById('receiverN').value);
			}

			this.setSenderN = function () {
				var n = this.getSenderN();
				display.setNsender(n, sender.base);
				sender.N = n;
			}

			this.setReceiverN = function () {
				var n = this.getReceiverN();
				display.setNreceiver(n, receiver.base);
				receiver.N = n;
			}

			this.updateEndToEndDelay = function () {
				endToEndDelay = (length / propagation) * 1000;
				TimeoutMin = (2 * endToEndDelay) + ackTT;
				var PPD;
				var TM;
				speedWarning();
				if (endToEndDelay >= 1000) {
					PPD = endToEndDelay / 1000;
					document.getElementById('unitPD').value = 1;
				}
				if (endToEndDelay >= 1 && endToEndDelay < 1000) {
					PPD = endToEndDelay;
					document.getElementById('unitPD').value = 1000;
				}
				if (endToEndDelay >= 0 && endToEndDelay < 1) {
					PPD = endToEndDelay * 1000;
					document.getElementById('unitPD').value = 1000000;
				}
				if (PPD % parseInt(PPD) != 0) {
					PPD = Number.parseFloat(PPD).toFixed(4);
				}
				document.getElementById('endToEndDelay2').value = PPD;

				if (TimeoutMin >= 1000) {
					TM = TimeoutMin / 1000;
					document.getElementById('unitMT').value = 1;
				}
				if (TimeoutMin >= 1 && TimeoutMin < 1000) {
					TM = TimeoutMin;
					document.getElementById('unitMT').value = 1000;
				}
				if (TimeoutMin >= 0 && TimeoutMin < 1) {
					TM = TimeoutMin * 1000;
					document.getElementById('unitMT').value = 1000000;
				}
				if (TM % parseInt(TM) != 0) {
					TM = Number.parseFloat(TM).toFixed(4);
				}
				document.getElementById('TimeoutMin').value = TM;
				document.getElementById('timeout').min = TimeoutMin;
			}

			this.updateNumberUI = function () {
				numberUI = Math.floor(dataSize / unitSize);
				if (dataSize % unitSize > 0)
					numberUI += 1;
				document.getElementById('NumberUI').value = numberUI;
			}

			this.updateAckTT = function () {
				ackTT = (ackSize / capacity) * 1000;
				TimeoutMin = (2 * endToEndDelay) + ackTT;
				var ATT;
				var TM;
				speedWarning();
				if (ackTT >= 1000) {
					ATT = ackTT / 1000;
					document.getElementById('unitAT').value = 1;
				}
				if (ackTT >= 1 && ackTT < 1000) {
					ATT = ackTT;
					document.getElementById('unitAT').value = 1000;
				}
				if (ackTT >= 0 && ackTT < 1) {
					ATT = ackTT * 1000;
					document.getElementById('unitAT').value = 1000000;
				}
				if (ATT % parseInt(ATT) != 0) {
					ATT = Number.parseFloat(ATT).toFixed(4);
				}
				document.getElementById('AckTT').value = ATT;

				if (TimeoutMin >= 1000) {
					TM = TimeoutMin / 1000;
					document.getElementById('unitMT').value = 1;
				}
				if (TimeoutMin >= 1 && TimeoutMin < 1000) {
					TM = TimeoutMin;
					document.getElementById('unitMT').value = 1000;
				}
				if (TimeoutMin >= 0 && TimeoutMin < 1) {
					TM = TimeoutMin * 1000;
					document.getElementById('unitMT').value = 1000000;
				}
				if (TM % parseInt(TM) != 0) {
					TM = Number.parseFloat(TM).toFixed(4);
				}
				document.getElementById('TimeoutMin').value = TM;
				document.getElementById('timeout').min = TimeoutMin;
			}

			this.autoSpeedControl = function () {
				autoscale = document.getElementById('autospeed').checked;
				if (autoscale) {
					document.getElementById('PDspeed').disabled = false;
				}
				else {
					document.getElementById('PDspeed').disabled = true;
				}
			}

			this.getTimeout = function () {
				return parseFloat(document.getElementById('timeout').value);
			}

			this.setTimeout = function () {
				sender.timeout = this.getTimeout() * parseInt(document.getElementById('unitTimeout').value);

			}

			this.getCapacity = function () {
				return parseFloat(document.getElementById('Capacity').value);
			}

			this.setCapacity = function () {
				capacity = this.getCapacity() * parseInt(document.getElementById('unitc').value);
				this.updatePkgPerMin();
				this.updateAckTT();
			}

			this.SetDefaultC = function (value, u) {
				document.getElementById('Capacity').value = value;
				document.getElementById('unitc').value = u;
				this.setCapacity();
			}

			this.getLength = function () {
				return parseFloat(document.getElementById('Length').value);
			}

			this.setLength = function () {
				length = this.getLength() * parseInt(document.getElementById('unitl').value);
				this.updateEndToEndDelay();
			}

			this.SetDefaultL = function (value, u) {
				document.getElementById('Length').value = value;
				document.getElementById('unitl').value = u;
				this.setLength();
			}

			this.getPropagation = function () {
				return parseFloat(document.getElementById('Propagation').value);
			}

			this.setPropagation = function () {
				propagation = this.getPropagation() * parseInt(document.getElementById('unitp').value);
				this.updateEndToEndDelay();
			}

			this.SetDefaultP = function (value, u) {
				document.getElementById('Propagation').value = value;
				document.getElementById('unitp').value = u;
				this.setPropagation();
			}

			this.getDataSize = function () {
				return parseFloat(document.getElementById('DataSize').value);
			}

			this.setDataSize = function () {
				dataSize = this.getDataSize() * parseInt(document.getElementById('unitd').value);
				this.updateNumberUI()
				initAnimation(contr.getMethod());
			}

			this.SetDefaultD = function (value, u) {
				document.getElementById('DataSize').value = value;
				document.getElementById('unitd').value = u;
				this.setDataSize();
			}

			this.getUnitSize = function () {
				return parseInt(document.getElementById('UnitSize').value);
			}

			this.setUnitSize = function () {
				unitSize = this.getUnitSize() * parseInt(document.getElementById('unitu').value);
				this.updateNumberUI();
				this.updatePkgPerMin();
				initAnimation(contr.getMethod());
			}

			this.SetDefaultU = function (value, u) {
				document.getElementById('UnitSize').value = value;
				document.getElementById('unitu').value = u;
				this.setUnitSize();
			}

			this.getAckSize = function () {
				return parseInt(document.getElementById('AckSize').value);
			}

			this.setAckSize = function () {
				ackSize = this.getAckSize() * parseInt(document.getElementById('unita').value);
				this.updateAckTT();
				this.updateEndToEndDelay();
				initAnimation(contr.getMethod());
			}

			this.SetDefaultA = function (value, u) {
				document.getElementById('AckSize').value = value;
				document.getElementById('unita').value = u;
				this.setAckSize();
			}


			this.getPDsimulationSpeed = function () {
				var e = document.getElementById('PDspeed');
				return parseInt(e.value);
			}

			this.setPDsimulationSpeed = function () {
				PDspeedFactor = this.getPDsimulationSpeed();
			}

			this.speedscale = function () {

				if (autoscale) {
					if (this.timeBetweenPkgs >= 0.000001 && this.timeBetweenPkgs <= 1000000 && endToEndDelay >= 0.000001 && endToEndDelay <= 1000000) {
						mintx = 2 * endToEndDelay + ackTT;
						if (sender.N * this.timeBetweenPkgs > 2 * endToEndDelay + ackTT) {
							sizecheck = 1;
							totaltimef1 = (this.timeBetweenPkgs * numberUI) + ackTT + 2 * endToEndDelay;
						}
						else {
							sizecheck = 2;
							totaltimef1 = (Math.floor(numberUI / sender.N)) * ((sender.N * this.timeBetweenPkgs) + ackTT + 2 * endToEndDelay) + (numberUI % sender.N) * this.timeBetweenPkgs + ackTT + 2 * endToEndDelay;
						}
						ackTT = convertRange(ackTT, [0.000001, 1000000], [1000 + PDspeedFactor, 5000 + PDspeedFactor]);
						this.timeBetweenPkgs = convertRange(this.timeBetweenPkgs, [0.000001, 1000000], [1000 + PDspeedFactor, 5000 + PDspeedFactor]);
						endToEndDelay = convertRange(endToEndDelay, [0.000001, 1000000], [1000 + PDspeedFactor, 5000 + PDspeedFactor]);
						sender.timeout *= ((2 * endToEndDelay + ackTT) / mintx);
						if (sizecheck == 1)
							totaltimef = totaltimef1 / ((this.timeBetweenPkgs * numberUI) + ackTT + 2 * endToEndDelay);
						if (sizecheck == 2)
							totaltimef = totaltimef1 / ((Math.floor(numberUI / sender.N)) * ((sender.N * this.timeBetweenPkgs) + ackTT + 2 * endToEndDelay) + (numberUI % sender.N) * this.timeBetweenPkgs + ackTT + 2 * endToEndDelay);
					}
					else {

					}

				}
				else {
					sizecheck = 0;
					sizecheck = 0;
					ackTT = (ackSize / capacity) * 1000;
					this.timeBetweenPkgs = (unitSize / capacity) * 1000;
					endToEndDelay = (length / propagation) * 1000;
					sender.timeout = 60;
				}
			}


			this.isPaused = false;
			this.pause = function () {
				if (this.isPaused === false) {
					if (this.running)
						window.clearInterval(this.interval);

					$('.pkg').pause();
					$.each(runningTimers, function (index, element) {
						element.pause();
					});
					$('.pkg').each(function () {
						var t = $(this).children('canvas').data('timer');
						if (typeof t != 'undefined')
							t.pause();
					});
					if (typeof display.windowTimer != 'undefined' && typeof display.windowTimer.data('timer') != 'undefined')
						display.windowTimer.data('timer').pause();

					this.isPaused = true;
				}
				else {
					this.setPkgPerMin();
					this.isPaused = false;

					$('.pkg').resume();
					$.each(runningTimers, function (index, element) {
						element.start();
					});
					$('.pkg').each(function () {
						var t = $(this).children('canvas').data('timer');
						if (typeof t != 'undefined')
							t.resume();
					});
					if (typeof display.windowTimer != 'undefined' && typeof display.windowTimer.data('timer') != 'undefined')
						display.windowTimer.data('timer').resume();
				}
				document.getElementById('pause').value = (this.isPaused ? 'resume' : 'pause');
			}

			this.updatePkgPerMin = function () {
				this.timeBetweenPkgs = (unitSize / capacity) * 1000;
				speedWarning();
				var TTT;
				if (this.timeBetweenPkgs >= 1000) {
					TTT = this.timeBetweenPkgs / 1000;
					document.getElementById('unitTT').value = 1;
				}
				if (this.timeBetweenPkgs >= 1 && this.timeBetweenPkgs < 1000) {
					TTT = this.timeBetweenPkgs;
					document.getElementById('unitTT').value = 1000;
				}
				if (this.timeBetweenPkgs >= 0 && this.timeBetweenPkgs < 1) {
					TTT = this.timeBetweenPkgs * 1000;
					document.getElementById('unitTT').value = 1000000;
				}
				if (TTT % parseInt(TTT) != 0) {
					TTT = Number.parseFloat(TTT).toFixed(4);
				}
				document.getElementById('TransmissionTime').value = TTT;

			}

			this.running = false;
			this.interval;
			this.timeBetweenPkgs = (unitSize / capacity) * 1000;
			this.emit = function () {
				sender.send(1);
			}

			this.startStop = function () {
				if (this.running) {
					window.clearInterval(this.interval);
					contr.speedscale();
					//	document.getElementById('reset').disabled = false;
					document.getElementById('senderN').disabled = false;
					document.getElementById('autospeed').disabled = false;
					if (document.getElementById('autospeed').checked == true) {
						document.getElementById('PDspeed').disabled = false;
					}
				}
				else { // start
					if (autostop == 1) {
						autostop = 0;
						sizecheck = 0;
						sizecheck1 = 0;
						document.getElementById('TotalTime').value = "";
						initAnimation(contr.getMethod());
						contr.setCapacity();
						contr.setLength();
						contr.setPropagation();
						contr.setDataSize();
						contr.setUnitSize();
						contr.setAckSize();
						contr.setTimeout();
						contr.speedscale();

					}
					overall_time = (numberUI * (unitSize / capacity)) + (ackSize / capacity) + (2 * (length / propagation));
					console.log("Total time without error is " + overall_time + " s");
					document.getElementById('receiverN').disabled = true;
					document.getElementById('senderN').disabled = true;
					//	document.getElementById('reset').disabled = true;
					document.getElementById('autospeed').disabled = true;
					document.getElementById('PDspeed').disabled = true;
					timedCount();
					contr.speedscale();
					sender.send(1);
					window.clearInterval(this.interval);
					this.interval = window.setInterval('sender.send(1)', this.timeBetweenPkgs);
					disableFormItems(true);
				}
				this.running = !this.running;

				document.getElementById('start').value = (this.running ? 'Stop' : 'Start');
			}

			this.allPacketsReceived = function () {

				var CTT;
				ctotal1 = (Date.now() - start) * totaltimef;

				if (ctotal1 >= 1000) {
					CTT = ctotal1 / 1000;
					document.getElementById('unitTotal').value = 1;
				}
				if (ctotal1 >= 1 && ctotal1 < 1000) {
					CTT = ctotal1;
					document.getElementById('unitTotal').value = 1000;
				}
				if (ctotal1 >= 0 && ctotal1 < 1) {
					CTT = ctotal1 * 1000;
					document.getElementById('unitTotal').value = 1000000;
				}
				if (CTT % parseInt(CTT) != 0) {
					CTT = Number.parseFloat(CTT).toFixed(6);
				}
				document.getElementById('TotalTime').value = CTT;
				ctotal = 0;
				if (this.running)
					return;

				disableFormItems(false);
			}
		}


		/**
		 * a Packet
		 * @param seqnum the sequence number of the packet
		 */
		function Packet(seqnum, data) {
			this.seqnum = seqnum;
			this.data = data;
			this.timer = null;

			this.send = function (dst, timeout) {
				var self = this;
				this.timer = new Timer(function () {
					dst.receive(self);
				}, (dst == sender ? timeout : timeout));
			}
			this.received = function () {
				this.timer.stop();
			}
			this.kill = function () {
				this.timer.stop();
			}
		}

		/**
		 * this sender can send with the go back n protocol
		 */
		function SenderGBN(N) {
			this.partner; // the end point the packets go to
			this.base = 1;
			this.nextseqnum = 1;
			this.N = N;
			this.pkt = new Array();
			this.timeout = 60; // time until the timeout is fired
			this.timers = new Array();	// an array of timers one for each packet
			this.timerscheck = new Array();



			// this method is called when a timeout occurs
			this.timeoutHandler = function (seqnum) {
				console.log("Timeout of packet " + (seqnum - 1));
				this.timerscheck.push(seqnum);
				unlock = true;
			}


			// sends a new packet to the partner
			this.send = function send(data) {
				if (this.nextseqnum < this.base + this.N || unlock) {
					if (this.nextseqnum <= numberUI || unlock) {
						if (unlock) {
							console.log("Send packet " + (this.timerscheck[0] - 1));
							this.pkt[this.timerscheck[0]].send(this.partner, endToEndDelay + contr.timeBetweenPkgs);
							display.send(true, this.pkt[this.timerscheck[0]]);
							var self = this;
							var seqnum = this.timerscheck[0];
							this.timers[seqnum] = new Timer(
								function () {
									self.timeoutHandler(seqnum);

								}, this.timeout + contr.timeBetweenPkgs
							);
							display.startPkgTimer(seqnum, this.timeout);
							this.timerscheck.shift();
							if (this.timerscheck.length == 0) {
								unlock = false;
							}
						} else {
							this.pkt[this.nextseqnum] = new Packet(this.nextseqnum, data);
							this.pkt[this.nextseqnum].confirmed = false;
							for (i = 1; i < this.base; i++) {
								// stop timer
								this.timers[i].stop();
								display.stopPkgTimer(i);
							}
							console.log("Send packet " + (this.nextseqnum - 1));
							this.pkt[this.nextseqnum].send(this.partner, endToEndDelay + contr.timeBetweenPkgs);
							display.send(true, this.pkt[this.nextseqnum]);

							// start timer for every packet
							var self = this;
							var seqnum = self.nextseqnum;
							this.timers[this.nextseqnum] = new Timer(
								function () {
									self.timeoutHandler(seqnum);

								}, this.timeout + contr.timeBetweenPkgs
							);
							display.startPkgTimer(this.nextseqnum, this.timeout);
							this.nextseqnum++;
							return true;
						}
					}
					else if (this.base == this.nextseqnum) {
						autostop = 1;
						this.nextseqnum = 1;
						contr.startStop();
					}
				}
				else {
					//	console.log("refuse packet "+ this.nextseqnum-1);
					return false;
				}
			}

			// receive an Ack
			this.receive = function (ack) {
				var n = ack.seqnum;
				for (i = 1; i < this.base; i++) {
					// stop timer
					this.timers[i].stop();
					display.stopPkgTimer(i);
				}
				if (ack.data == 'NACK') {	// handles NACKs that is retransmitting the packet and reseting its timer
					console.log("NACK of packet " + (ack.seqnum - 1) + " received");
					for (i = this.base; i < this.base + this.N && this.timers[i] != 'undefined'; i++) {
						if (this.timers[i] == undefined) {
							break;
						}
						// stop timer
						this.timers[i].stop();
						display.stopPkgTimer(i);
					}
					this.timerscheck = new Array();
					this.nextseqnum = this.base;
					unlock = false;
				} else if (n >= this.base) {	// handles ACKs that is when receives a cumulative ACK, stops past timers and moves the window
					console.log("ACK of packet " + (ack.seqnum - 1) + " received");
					if (n > this.base || this.timerscheck.length != 0) {
						var spli = this.timerscheck.indexOf(n);
						if (spli != -1) {
							spli++;
							this.timerscheck.splice(0, spli);
							unlock = false;
						}
					}
					for (i = this.base; i <= n; i++) {

						// stop timer
						this.timers[i].stop();
						display.stopPkgTimer(i);

						// mark packet as confirmed
						this.pkt[i].confirmed = true;
						display.confirmSender(i);
					}
					display.setSenderBase(n + 1 - this.base, n + 1);	// moves the window to last ACK received
					this.base = n + 1;
				}
			}
		}

		function ReceiverGBN() {
			this.partner; // the end point the packets come from
			this.expectedseqnum = 1;
			this.sndpkt = new Packet(0, 'ACK');

			// receive a packet
			this.receive = function (packet) {
				if (packet.seqnum == this.expectedseqnum) {	// if the packet is what expected it sends back the ack
					console.log("Packet " + (packet.seqnum - 1) + " received: send ack");
					this.sndpkt = new Packet(this.expectedseqnum, 'ACK');
					display.confirmReceiver(this.sndpkt.seqnum);
					display.deliverPkg(this.sndpkt.seqnum);
					NACKFlag = false;
					this.expectedseqnum++;
					this.sndpkt.send(this.partner, endToEndDelay + ackTT);
					display.send(false, this.sndpkt);
					display.setReceiverBase(1, this.expectedseqnum);
				}
				else {
					console.log("Packet " + (packet.seqnum - 1) + " received is UNEXPECTED. NACKs enabled: " + nacksEnabled);
					if (nacksEnabled) {
						if (packet.seqnum > this.expectedseqnum && NACKFlag == false) {	// cheks if NACK has been sent before
							NACKFlag = true;
							this.sndpkt = new Packet(this.expectedseqnum, 'NACK');
							this.sndpkt.send(this.partner, endToEndDelay + ackTT);
							display.send(false, this.sndpkt);
						}
						else if (this.expectedseqnum != 1) {		//Sends the old ACK for each out of sequence packet
							this.sndpkt = new Packet(this.expectedseqnum - 1, 'ACK');
							this.sndpkt.send(this.partner, endToEndDelay + ackTT);
							display.send(false, this.sndpkt);
						}
					} else if (this.expectedseqnum != 1) { // If NACKs are *disabled*, always send duplicate ACK
						console.log("NACKs disabled. Sending duplicate ACK for packet " + (this.expectedseqnum - 2));
						this.sndpkt = new Packet(this.expectedseqnum - 1, 'ACK');
						this.sndpkt.send(this.partner, endToEndDelay + ackTT);
						display.send(false, this.sndpkt);
					}
				}
			}
		}

		function init() {
			contr = new Controller();
			contr.SetDefaultC(1, 1000);
			contr.SetDefaultL(1, 1000);
			contr.SetDefaultP(200000, 1000);
			contr.SetDefaultD(10, 1000);
			contr.SetDefaultU(500, 1);
			contr.SetDefaultA(20, 1);
			display.setNsender(5, sender.base);
			sender.N = 5;
			document.getElementById('receiverN').value = 1;
			display.setNreceiver(1, receiver.base);
			receiver.N = 1;
			sender.timeout = 40;
			document.getElementById('senderN').value = 5;
			document.getElementById('timeout').value = 60;
			document.getElementById('timeout').min = TimeoutMin;
			document.getElementById('TotalTime').value = "";
			document.getElementById('autospeed').checked = true;
			document.getElementById('PDspeed').value = 0;
			document.getElementById("speedwarning").style.display = "none";
			document.getElementById('PDspeed').disabled = false;
			autoscale = true;
			PDspeedFactor = 0;
			document.getElementById('unitTimeout').value = 1;
			initAnimation(contr.getMethod());

			// Create starry background
			createStarryBackground();

			// Setup sidebar toggle functionality
			const sidebarToggle = document.getElementById('sidebar-toggle');
			const sidebar = document.getElementById('sidebar');
			const mainContent = document.getElementById('main-content');
			const headerHeading = document.querySelector('header .headingName'); // Target the h1

			sidebarToggle.addEventListener('click', function () {
				sidebar.classList.toggle('closed');
				mainContent.classList.toggle('expanded');
				sidebarToggle.classList.toggle('closed');
				sidebarToggle.textContent = sidebar.classList.contains('closed') ? '☰' : '×';

				// When sidebar is closed, center the h1; otherwise, align it left (or any default alignment)
				if (sidebar.classList.contains('closed')) {
					headerHeading.style.marginLeft = '0px';
				} else {
					headerHeading.style.marginLeft = "400px";
				}
			});


			// Setup tab functionality
			const tabButtons = document.querySelectorAll('.tab-button');
			const tabContents = document.querySelectorAll('.tab-content');

			tabButtons.forEach(button => {
				button.addEventListener('click', () => {
					// Remove active class from all buttons and contents
					tabButtons.forEach(btn => btn.classList.remove('active'));
					tabContents.forEach(content => content.classList.remove('active'));

					// Add active class to clicked button and corresponding content
					button.classList.add('active');
					const tabId = button.getAttribute('data-tab');
					document.getElementById(tabId).classList.add('active');
				});
			});

			// Setup Theme Toggle
			const themeToggle = document.getElementById('theme-toggle');
			const body = document.body;
			const currentTheme = localStorage.getItem('theme');

			// Apply saved theme on load
			if (currentTheme === 'dark') {
				body.classList.add('dark-mode');
				themeToggle.innerHTML = '<img src= "../../sun.png" />'; // Sun icon for light mode
			} else {
				themeToggle.innerHTML = '<img src= "../../moon.png" />'; // Moon icon for dark mode
			}

			themeToggle.addEventListener('click', () => {
				body.classList.toggle('dark-mode');
				let theme = 'light';
				if (body.classList.contains('dark-mode')) {
					theme = 'dark';
					themeToggle.innerHTML = '<img src= "../../sun.png" />';
				} else {
					themeToggle.innerHTML = '<img src= "../../moon.png" />';
				}
				localStorage.setItem('theme', theme);
			});
		}

		function initAnimation(method) {
			display = null;
			sender = null;
			receiver = null;
			for (var t in runningTimers)
				runningTimers[t].stop();

			var senderN = contr.getSenderN();
			var receiverN = contr.getReceiverN();


			switch (method) {
				case 'gbn':
					display = new Display(senderN, receiverN, true);
					sender = new SenderGBN(senderN);
					receiver = new ReceiverGBN(receiverN);
					document.getElementById('receiverN').value = "1";
					document.getElementById('receiverN').disabled = true;
					break;
			}

			sender.partner = receiver;
			receiver.partner = sender;

			contr.updateEndToEndDelay();
			contr.setTimeout();

		}


		function Display(windowNsender, windowNreceiver, hasWindowReceiver) {

			// --- Configuration Constants ---
			// --- >> MODIFIED VALUES << ---
			const PKG_WIDTH = 40;          // Visual width of a packet element (Changed from 24)
			const PKG_HEIGHT = 50;         // Visual height of a packet element (Changed from 30)
			const WINDOW_HEIGHT = 55;      // Height of the window visualization divs (Increased from 34 for proportion)
			const WINDOW_TIMER_SIZE = 50;  // Size (width & height) for the main window timer canvas (Increased from 40)
			// --- >> END OF MODIFIED VALUES << ---

			const PKG_CANVAS_SIZE = 30;    // Size (width & height) of the canvas inside sender packets (Kept at 30, adjust if desired)
			const PKG_GAP = 10;            // Horizontal gap between packet elements (Kept at 10, adjust if desired)
			const PKG_TOTAL_SPACING = PKG_WIDTH + PKG_GAP; // Total horizontal space per packet (NOW: 40 + 10 = 50px)
			const WINDOW_PADDING = 4;      // Padding inside the window visualization divs
			const BASE_OFFSET_X = 10;      // Initial horizontal offset for the first packet
			const FINE_TUNE_OFFSET = -2;   // Small adjustment for window positioning (may need tweaking)
			const SENDER_Y = 10;           // Top position for sender elements
			const RECEIVER_Y = 360;        // Top position for receiver elements
			const SENDER_WINDOW_Y = 8;     // Top position for the sender window visual
			const RECEIVER_WINDOW_Y = 358; // Top position for the receiver window visual


			// --- Initialization ---
			this.paper = $('#root'); // Main container jQuery object
			this.paper.children(':not(div.desc)').remove(); // Clear previous simulation elements
			this.paper.css({ 'left': '0px' }); // Reset horizontal scroll

			this.windowNsender = windowNsender;     // Current sender window size N
			this.windowNreceiver = windowNreceiver; // Current receiver window size N
			this.windowOffset = 5; // Offset used in sequence number calculations? (Legacy or specific purpose)
			this.seqnumToPkg = {}; // Map: sequence number -> {sender: jQueryObj, receiver: jQueryObj}
			this.windowSender;     // jQuery object for the sender window visual
			this.windowReceiver;   // jQuery object for the receiver window visual
			this.xOffset = 0;      // Current horizontal scroll offset of the 'paper' container
			this.nextFreeSeqNum = 1 - this.windowOffset; // Sequence number for the next packet to create
			this.nextFreePkgIndex = 0; // Horizontal index for the next packet element
			this.nextSeqNumToRemove = 0; // Lowest sequence number potentially scrolled off-screen
			this.windowTimer;      // jQuery object for the GBN-style window timer canvas
			this.packetsAlive = 0; // Counter for packets currently animating (in transit)

			// --- Methods ---

			/** Decrements the count of animating packets and checks if simulation is done. */
			this.packetsAliveDec = function (seqnum) {
				this.packetsAlive--;
				//console.log('Packets alive:', this.packetsAlive, 'Seqnum finished:', seqnum);
				this.alive();
			};

			/** Checks if all packets/timers are finished, signaling simulation end. */
			this.alive = function () {
				// Check if no packets animating, no individual packet timers running, and window timer not started
				if (this.packetsAlive === 0 && Object.keys(this.pkgTimers).length === 0 && !this.windowTimerStarted) {
					// Assuming 'contr' is a global controller object
					if (typeof contr !== 'undefined' && typeof contr.allPacketsReceived === 'function') {
						contr.allPacketsReceived();
					} else {
						console.warn("Controller 'contr' or 'allPacketsReceived' method not found.");
					}
				}
			};

			/** Creates or updates the visual representation of the sender's window. */
			this.setNsender = function (windowNsender, base) {
				this.windowNsender = windowNsender;

				// Calculate window position and width using constants
				const x = BASE_OFFSET_X + PKG_TOTAL_SPACING * (base + this.windowOffset - 1) + FINE_TUNE_OFFSET;
				const widthSender = WINDOW_PADDING + this.windowNsender * PKG_WIDTH + Math.max(0, this.windowNsender - 1) * PKG_GAP;

				if (typeof this.windowSender === 'undefined') {
					// --- First time creation ---
					this.windowSender = $('<div> </div>').css({
						left: x + 'px',
						top: SENDER_WINDOW_Y + 'px',
						width: widthSender + 'px',
						height: WINDOW_HEIGHT + 'px' // Use updated WINDOW_HEIGHT
					}).attr('class', 'window').appendTo(this.paper);

					// Create Window timer canvas (typically for GBN) if receiver window isn't shown
					if (!hasWindowReceiver) {
						// Create with updated WINDOW_TIMER_SIZE and adjust vertical position based on new WINDOW_HEIGHT
						this.windowTimer = $(`<canvas height="${WINDOW_TIMER_SIZE}" width="${WINDOW_TIMER_SIZE}"> </canvas>`).css({
							left: x + 'px', // Position timer with window
							top: (SENDER_WINDOW_Y - WINDOW_TIMER_SIZE / 2 + WINDOW_HEIGHT / 2) + 'px' // Recalculate vertical center
						}).attr('class', 'window-timer').appendTo(this.paper);
					}
				} else {
					// --- Update existing window ---
					this.windowSender.css('width', widthSender + 'px');
					// Also update height in case it changes dynamically elsewhere (unlikely here, but good practice)
					this.windowSender.css('height', WINDOW_HEIGHT + 'px');
				}
			};

			/** Creates or updates the visual representation of the receiver's window. */
			this.setNreceiver = function (windowNreceiver, base) {
				this.windowNreceiver = windowNreceiver;

				// Calculate window position and width using constants
				const x = BASE_OFFSET_X + PKG_TOTAL_SPACING * (base + this.windowOffset - 1) + FINE_TUNE_OFFSET;
				const widthReceiver = WINDOW_PADDING + this.windowNreceiver * PKG_WIDTH + Math.max(0, this.windowNreceiver - 1) * PKG_GAP;

				if (typeof this.windowReceiver === 'undefined') {
					// --- First time creation ---

					// Create Window timer only if GBN style AND it wasn't created by setNsender
					if (!hasWindowReceiver && !this.windowTimer) {
						console.warn("Creating window timer in setNreceiver - unusual for GBN.");
						// Use updated size/positioning if created here
						this.windowTimer = $(`<canvas height="${WINDOW_TIMER_SIZE}" width="${WINDOW_TIMER_SIZE}"> </canvas>`).css({
							left: x + 'px',
							top: (SENDER_WINDOW_Y - WINDOW_TIMER_SIZE / 2 + WINDOW_HEIGHT / 2) + 'px'
						}).attr('class', 'window-timer').appendTo(this.paper);
					}

					// Create receiver window visual only if requested
					if (hasWindowReceiver) {
						this.windowReceiver = $('<div> </div>').css({
							left: x + 'px',
							top: RECEIVER_WINDOW_Y + 'px',
							width: widthReceiver + 'px',
							height: WINDOW_HEIGHT + 'px' // Use updated WINDOW_HEIGHT
						}).attr('class', 'window').appendTo(this.paper);
					}
				} else {
					// --- Update existing window ---
					if (hasWindowReceiver && this.windowReceiver) { // Check if it exists before updating
						this.windowReceiver.css('width', widthReceiver + 'px');
						// Also update height
						this.windowReceiver.css('height', WINDOW_HEIGHT + 'px');
					}
				}
			};

			/** Creates the visual elements (sender/receiver placeholders) for one packet. */
			this.createPackets = function () {
				// Check for potential 'numberUI' global variable dependency
				let displaySeqNum = '';
				if (typeof numberUI !== 'undefined') {
					// Use logical AND && instead of bitwise &
					displaySeqNum = (this.nextFreeSeqNum > 0 && this.nextFreeSeqNum <= numberUI) ? (this.nextFreeSeqNum - 1) : (''); // Display actual seq num
				} else {
					// Fallback if numberUI is not defined
					displaySeqNum = (this.nextFreeSeqNum > 0) ? (this.nextFreeSeqNum - 1) : ('');
				}

				const currentX = BASE_OFFSET_X + this.nextFreePkgIndex * PKG_TOTAL_SPACING;

				// Create sender-side packet visual (div with canvas and sequence number)
				const senderDiv = $(`
            <div>
                <canvas width="${PKG_CANVAS_SIZE}" height="${PKG_CANVAS_SIZE}"></canvas>
                <center class="centreRotate"><b>${displaySeqNum}</b></center>
            </div>
        `).css({
					left: currentX + 'px',
					top: SENDER_Y + 'px',
					width: PKG_WIDTH + 'px', // Set width explicitly
					height: PKG_HEIGHT + 'px' // **Set height explicitly using the constant**
				}).attr('class', 'pkg')
					.data('index', this.nextFreePkgIndex) // Store index for positioning calculations
					.appendTo(this.paper);

				// Create receiver-side packet placeholder visual (div with sequence number)
				const receiverDiv = $(`
            <div>
                <center class="centreRotate"><b>${displaySeqNum}</b></center>
            </div>
        `).css({
					left: currentX + 'px',
					top: RECEIVER_Y + 'px',
					width: PKG_WIDTH + 'px', // Set width explicitly
					height: PKG_HEIGHT + 'px' // **Set height explicitly using the constant**
				}).attr('class', 'pkg empty') // Starts as an empty slot
					.data('index', this.nextFreePkgIndex)
					.appendTo(this.paper);

				// Store references in the map
				this.seqnumToPkg[this.nextFreeSeqNum] = { 'sender': senderDiv, 'receiver': receiverDiv };

				// Increment for the next packet
				this.nextFreeSeqNum++;
				this.nextFreePkgIndex++;
			};

			// --- Initial Setup Execution ---
			// Create initial batch of packet placeholders
			for (let i = 0; i < 30; i++) { // Create 30 initial slots
				this.createPackets();
			}
			// Draw the initial windows based on constructor parameters
			this.setNsender(this.windowNsender, 1); // Draw sender window starting at base 1
			this.setNreceiver(this.windowNreceiver, 1); // Draw receiver window starting at base 1

			// --- State Change Methods ---

			/** Marks a sender packet as confirmed (acknowledged). */
			this.confirmSender = function (seqnum) {
				if (this.seqnumToPkg[seqnum]) {
					$(this.seqnumToPkg[seqnum].sender).attr('class', 'pkg confirmed');
				}
			};

			/** Marks a receiver placeholder as ready (data acknowledged). */
			this.confirmReceiver = function (seqnum) {
				if (this.seqnumToPkg[seqnum]) {
					$(this.seqnumToPkg[seqnum].receiver).attr('class', 'pkg'); // Removes 'empty' or 'delivered'
				}
			};

			/** Marks a receiver packet as delivered to the application layer. */
			this.deliverPkg = function (seqnum) {
				if (this.seqnumToPkg[seqnum]) {
					$(this.seqnumToPkg[seqnum].receiver).attr('class', 'pkg delivered');
				}
			};

			// --- Window Sliding and Scrolling ---
			let xOffsetLast = this.xOffset; // Track previous offset for scrolling condition

			/** Slides the sender window and potentially scrolls the view. */
			this.setSenderBase = function (count, newBase) {
				if (count === 0 || !this.seqnumToPkg[newBase]) return; // No move or target packet doesn't exist

				// Update total horizontal offset
				this.xOffset += count * PKG_TOTAL_SPACING; // Uses updated PKG_TOTAL_SPACING

				// Create new packet placeholders at the tail end as the view expands
				for (let i = 0; i < count; i++) {
					this.createPackets();
				}

				// Calculate the new horizontal pixel position for the sender window
				const newX = BASE_OFFSET_X + this.seqnumToPkg[newBase].sender.data('index') * PKG_TOTAL_SPACING + FINE_TUNE_OFFSET;

				// Animate the sender window smoothly to the new position
				if (this.windowSender) {
					this.windowSender.stop(true).animate({ 'left': newX + 'px' }, 100);
				}

				// Animate the window timer canvas along with the window if it exists
				if (this.windowTimer) {
					this.windowTimer.stop(true).animate({ 'left': newX + 'px' }, 100);
				}

				// Check if the 'paper' container needs to be scrolled left
				const scrollThreshold = 750; // Viewport width threshold (adjust as needed)
				let shouldScroll = false;
				if (typeof typewriter !== 'undefined' && !typewriter) { // Check if typewriter mode is off
					shouldScroll = true;
				} else if (this.windowSender) { // Check if right edge goes beyond threshold
					// Use windowSender.width() which reflects the calculation using new PKG_WIDTH
					shouldScroll = (newX + this.windowSender.width() - xOffsetLast >= scrollThreshold);
				} else {
					// Estimate if window not ready (less accurate but fallback)
					shouldScroll = (newX + PKG_TOTAL_SPACING * this.windowNsender - xOffsetLast >= scrollThreshold);
				}


				if (shouldScroll) {
					const displayObj = this; // Use 'displayObj' or similar distinct name for 'this' in callback
					this.paper.stop(true).animate({
						left: -this.xOffset + "px" // Move container left
					}, 400, function () { // Animation complete callback
						// --- Cleanup Off-Screen Elements ---
						for (let i = displayObj.nextSeqNumToRemove; i < displayObj.nextFreeSeqNum; i++) {
							const packetElements = displayObj.seqnumToPkg[i];
							if (packetElements && packetElements.sender) {
								// Check if the element's left edge is completely off-screen
								// Uses updated PKG_TOTAL_SPACING for threshold
								if (packetElements.sender.offset().left < -PKG_TOTAL_SPACING) {
									// Remove both sender and receiver elements from DOM
									packetElements.sender.remove();
									packetElements.receiver.remove();
									// Delete the entry from the map
									delete displayObj.seqnumToPkg[i];
									// Increment the sequence number tracking the removal front
									displayObj.nextSeqNumToRemove++;
									//console.log('Removed packet elements for seqnum:', i);
								} else {
									// Stop checking once we find a packet still on-screen
									break;
								}
							} else if (i >= displayObj.nextSeqNumToRemove) {
								// Optional: handle missing elements during cleanup
								// displayObj.nextSeqNumToRemove = i + 1; 
							}
						}
					});
					xOffsetLast = this.xOffset; // Update the last offset after initiating scroll
				}
			};

			/** Slides the receiver window (if displayed). */
			this.setReceiverBase = function (count, newBase) {
				if (count === 0 || !hasWindowReceiver || !this.windowReceiver || !this.seqnumToPkg[newBase]) {
					return; // No move needed, or window/target packet doesn't exist
				}

				// Calculate the new horizontal pixel position for the receiver window
				const newX = BASE_OFFSET_X + this.seqnumToPkg[newBase].sender.data('index') * PKG_TOTAL_SPACING + FINE_TUNE_OFFSET;

				// Animate the receiver window smoothly
				this.windowReceiver.stop(true).animate({ left: newX + 'px' }, 200);
			};

			/** Animates a packet/ACK/NACK between sender and receiver areas. */
			this.send = function (toReceiver, pkg, value) { // 'value' parameter seems unused
				const seqnum = pkg.seqnum;
				const isNack = pkg.data === 'NACK'; // Check if it's a NACK

				// Assumed global variables (ensure they are defined elsewhere)
				const endToEndDelay = typeof window.endToEndDelay !== 'undefined' ? window.endToEndDelay : 1000; // Default 1s
				const timeBetweenPkgs = (typeof contr !== 'undefined' && contr.timeBetweenPkgs) ? contr.timeBetweenPkgs : 100; // Default 100ms
				const ackTT = typeof window.ackTT !== 'undefined' ? window.ackTT : 50; // Default 50ms

				let originElement, startY, cssClass, initialMoveTargetY, finalTargetY, initialMoveTime;

				if (!this.seqnumToPkg[seqnum]) {
					console.warn(`Cannot send seqnum ${seqnum}, elements not found.`);
					return;
				}

				if (toReceiver) { // Data packet
					originElement = this.seqnumToPkg[seqnum].sender;
					startY = SENDER_Y;
					cssClass = 'pkg';
					initialMoveTargetY = SENDER_Y + 30; // Short downward move (keep relative move distance)
					finalTargetY = RECEIVER_Y;
					initialMoveTime = timeBetweenPkgs; // Time based on inter-packet gap
				} else { // ACK or NACK
					originElement = this.seqnumToPkg[seqnum].receiver;
					startY = RECEIVER_Y;
					cssClass = isNack ? 'pkg nack' : 'pkg ack'; // Different class for NACK
					initialMoveTargetY = RECEIVER_Y - 30; // Short upward move (keep relative move distance)
					finalTargetY = SENDER_Y;
					initialMoveTime = ackTT; // Time based on ACK transmission time
				}

				// Clone the origin element for animation
				// The clone will inherit the new width/height set in createPackets
				const animatedSquare = $(originElement).clone()
					.attr('class', cssClass) // Apply appropriate class
					.appendTo(this.paper)
					.css({
						top: startY + 'px',
						// Width/Height should be inherited from origin via clone if CSS is set correctly
						// width: $(originElement).width() + 'px', // Usually not needed if origin CSS is correct
						// height: $(originElement).height() + 'px',// Usually not needed if origin CSS is correct
						position: 'absolute' // Ensure it's positioned absolutely for animation
					});

				this.packetsAlive++; // Increment count of animating packets
				const self = this; // Reference to 'this' for callbacks

				// --- Animation Sequence ---
				animatedSquare
					// 1. Short initial move (simulates entering channel)
					.animate({ top: initialMoveTargetY + 'px' }, initialMoveTime, 'linear')
					// 2. Main travel across the channel
					.animate({ top: finalTargetY + 'px' }, endToEndDelay, 'linear', function () {
						// Animation Complete Callback:
						$(this).remove(); // Remove the animated clone
						self.packetsAliveDec(seqnum); // Decrement counter and check 'alive' status
					});

				// --- Click to Simulate Loss ---
				animatedSquare.on('mousedown', function (e) {
					e.preventDefault(); // Prevent potential text selection/drag behavior

					if (typeof pkg.kill === 'function') {
						pkg.kill(); // Call the packet's kill method if it exists
					} else {
						console.warn("Packet object does not have a kill() method.");
					}

					self.packetsAliveDec(seqnum); // Decrement counter, packet is "lost"

					$(this).stop(true) // Stop animation immediately
						.css({ background: '#ff0000', opacity: 0.7 }) // Visual feedback (red flash)
						.delay(150) // Wait briefly
						.fadeOut(100, function () { $(this).remove(); }); // Fade out and remove

					console.log(`${toReceiver ? 'Data' : (isNack ? 'NACK' : 'ACK')} ${seqnum} killed (simulated loss).`);
				});
			};

			// --- Timer Management ---
			this.pkgTimers = {}; // Object to store individual packet TimerCircle instances

			/** Starts the timeout timer visual for a specific sender packet. */
			this.startPkgTimer = function (seqnum, time) {
				if (!this.seqnumToPkg[seqnum] || !this.seqnumToPkg[seqnum].sender) {
					// console.warn(`Cannot start timer for seqnum ${seqnum}, sender element not found.`);
					return; // Packet scrolled off or doesn't exist
				}

				const canvas = this.seqnumToPkg[seqnum].sender.children('canvas');
				if (canvas.length === 0) {
					console.warn(`Canvas not found for seqnum ${seqnum}.`);
					return;
				}

				let timerInstance = canvas.data('timer');
				if (!timerInstance) {
					// Create TimerCircle instance using constant canvas size (PKG_CANVAS_SIZE)
					timerInstance = new TimerCircle(PKG_CANVAS_SIZE, canvas, 'pkg');
					canvas.data('timer', timerInstance); // Store it
				}

				// Delay start slightly (e.g., based on packet spacing time) - adjust if needed
				const startDelay = (typeof contr !== 'undefined' && contr.timeBetweenPkgs) ? contr.timeBetweenPkgs : 50;
				setTimeout(() => {
					if (canvas.data('timer')) { // Check if still exists before starting
						canvas.data('timer').start(time);
					}
				}, startDelay);
			};

			/** Stops and clears the timeout timer visual for a specific sender packet. */
			this.stopPkgTimer = function (seqnum) {
				if (!this.seqnumToPkg[seqnum] || !this.seqnumToPkg[seqnum].sender) {
					return; // Packet scrolled off or doesn't exist
				}

				const canvas = this.seqnumToPkg[seqnum].sender.children('canvas');
				const timerInstance = canvas.data('timer');

				if (timerInstance) {
					timerInstance.stop();
					// Optional: remove timer data to allow recreation if needed later
					// canvas.removeData('timer'); 
				}
				// No need to delete from this.pkgTimers here as it wasn't added

				this.alive(); // Check if simulation might be done
			};

			// --- Window Timer (Go-Back-N Style) ---
			this.windowTimerStarted = false; // Flag for the main GBN timer

			/** Starts the main window timer visual. */
			this.startWindowTimer = function (time) {
				if (!this.windowTimer) {
					console.warn("Attempted to start window timer, but canvas element doesn't exist.");
					return;
				}

				let timerInstance = this.windowTimer.data('timer');
				if (!timerInstance) {
					// Create TimerCircle instance for the window timer canvas using updated WINDOW_TIMER_SIZE
					timerInstance = new TimerCircle(WINDOW_TIMER_SIZE, this.windowTimer, 'window');
					this.windowTimer.data('timer', timerInstance);
				}

				timerInstance.start(time);
				this.windowTimerStarted = true;
			};

			/** Restarts the main window timer. */
			this.restartWindowTimer = function (time) {
				if (!this.windowTimer) return;

				const timerInstance = this.windowTimer.data('timer');
				if (timerInstance) {
					timerInstance.stop(); // Stop the current timer first
				}

				this.startWindowTimer(time); // Start a new one
			};

			/** Stops the main window timer visual. */
			this.stopWindowTimer = function () {
				if (!this.windowTimer) return;

				const timerInstance = this.windowTimer.data('timer');
				if (timerInstance) {
					timerInstance.stop();
				}
				this.windowTimerStarted = false; // Update flag

				this.alive(); // Check if simulation might be done
			};


			/**
			 * Inner Helper Class: TimerCircle (Implementation uses requestAnimationFrame)
			 * Creates and manages the animation of a circular countdown timer on a canvas.
			 * @param {number} size - The width and height of the canvas.
			 * @param {jQuery} canvasElement - The jQuery object representing the canvas.
			 * @param {'window'|'pkg'} type - The style of timer ('window' = outline, 'pkg' = filled).
			 */
			function TimerCircle(size, canvasElement, type) {
				const context = canvasElement[0].getContext('2d');
				let animationFrameId = null; // Store requestAnimationFrame ID
				let startTime = 0;
				let duration = 0;
				let isRunning = false;

				if (type !== 'window' && type !== 'pkg') {
					throw new Error(`TimerCircle type "${type}" is not defined`);
				}

				const draw = (percent) => {
					context.clearRect(0, 0, size, size); // Clear canvas
					if (percent <= 0) return;

					const value = percent / 100; // Normalize percent to 0-1
					const startAngle = -0.5 * Math.PI; // Start at 12 o'clock
					const endAngle = startAngle + (2 * Math.PI * value);

					context.save();
					context.beginPath();

					if (type === 'window') {
						// Adjust line width relative to the (potentially larger) timer size
						const lineWidth = Math.max(2, size * 0.15);
						const radius = size / 2 - lineWidth / 2;
						const centerX = size / 2;
						const centerY = size / 2;
						context.arc(centerX, centerY, radius, startAngle, endAngle, false);
						context.lineWidth = lineWidth;
						context.strokeStyle = '#ff00ff'; // Magenta
						context.lineCap = 'round'; // Use round caps
						context.stroke();
					} else { // 'pkg' type (filled) - PKG_CANVAS_SIZE is used here
						const radius = size / 2;
						const centerX = size / 2;
						const centerY = size / 2;
						context.moveTo(centerX, centerY); // Start from center
						context.arc(centerX, centerY, radius, startAngle, endAngle, false);
						context.closePath(); // Close path back to center
						context.fillStyle = '#ff00ff'; // Magenta
						context.fill();
					}
					context.restore();
				};

				const step = (timestamp) => {
					if (!isRunning) return; // Stop if stop() was called

					if (!startTime) {
						startTime = timestamp; // Record start time on first frame
					}
					const elapsed = timestamp - startTime;
					const remaining = Math.max(0, duration - elapsed);
					const percent = (remaining / duration) * 100;

					draw(percent);

					if (remaining > 0) {
						animationFrameId = requestAnimationFrame(step); // Continue animation
					} else {
						// Animation finished
						draw(0); // Ensure final state is cleared/empty
						isRunning = false;
						startTime = 0;
						animationFrameId = null; // Clear ID
					}
				};

				this.start = function (time) {
					if (isRunning) {
						this.stop();
					}
					duration = time;
					startTime = 0;
					isRunning = true;
					// Ensure drawing starts immediately even if RAF has slight delay
					draw(100);
					animationFrameId = requestAnimationFrame(step);
					return this;
				};

				this.stop = function () {
					if (animationFrameId) {
						cancelAnimationFrame(animationFrameId);
					}
					isRunning = false;
					startTime = 0;
					animationFrameId = null;
					context.clearRect(0, 0, size, size);
					return this;
				};

				// Basic pause/resume (might have timing drift on resume)
				let pausedTime = 0;
				this.pause = function () {
					if (isRunning) {
						cancelAnimationFrame(animationFrameId);
						pausedTime = performance.now();
						isRunning = false;
						animationFrameId = null;
					}
					return this;
				}
				this.resume = function () {
					if (!isRunning && pausedTime > 0 && duration > 0) {
						const pauseDuration = performance.now() - pausedTime;
						startTime += pauseDuration; // Adjust start time
						isRunning = true;
						pausedTime = 0;
						animationFrameId = requestAnimationFrame(step);
					}
					return this;
				}
			} // End of TimerCircle constructor

		} // End of Display constructor


	</script>
</head>

<body onload="init();" class="mobile">
	<header>
		<h1 class="headingName ibm-plex-sans-condensed-regular ">GO BACK N PROTOCOL</h1>
		<button id="theme-toggle" title="Toggle Theme"></button> <!-- Added Theme Toggle Button -->
	</header>

	<div class="container">
		<!-- Sidebar with Configuration and Legend -->
		<aside id="sidebar">
			<!-- Tab Navigation -->
			<div class="tab-buttons">
				<button class="tab-button active" data-tab="config-tab">Configuration</button>
				<button class="tab-button" data-tab="legend-tab">Legend</button>
			</div>

			<!-- Configuration Tab -->
			<div id="config-tab" class="tab-content active">
				<form class="config">
					<div class="form-item">
						<h3><label for="protocol">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">
									<span class="tooltiptext">This section is related to simulation control. Selecting the protocol type,
										animation window's style, and controlling the speed of the animation.</span>
								</div>
								Simulation settings:
							</label>
						</h3>

						<h5><label for="">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">By selecting this option the animation speed can be controled in such a way
										that you can easily see the animation and dropping an IU or an Ack.
									</span>
								</div>
								Speed control:

							</label></h5>

						<h5><label for="" id="speedwarning" hidden>
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">The speed control option can be only used if the values of IU transmission,
										Ack transmission and propagation delay are between
										1 nanoseconds and 1000 seconds.</span>
								</div>
								Can not be used in this case!

							</label></h5>

						<h5><label for="" id="speedfault">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">After selecting the speed control option, it is also possible to change the
										speed mode. </span>
								</div>
								<input type="checkbox" [disabled]="false" id="autospeed" onchange="contr.autoSpeedControl();">
								<select id="PDspeed" [disabled]="false" onchange="contr.setPDsimulationSpeed(this);">
									<option value="900">Very slow</option>
									<option value="500">Slow</option>
									<option value="0" selected="selected">Normal</option>
									<option value="-500">Fast</option>
									<option value="-900">Very fast</option>
								</select>
							</label></h5>


						<h5><label for="">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">Start, stop, reload, and log</span>
								</div>

								<input type="button" id="start" onclick="contr.startStop();" value="Start" />
								<input type="button" id="reload" onclick="window.location.reload();" value="Reload" />
								<input type="button" onclick="logger()" value="Log" />

							</label></h5>
					</div>

					<div class="form-item">
						<h3><label for="Window sizes">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">This section is related to window sizes of the sender and the receiver and
										the Timeout value.</span>
								</div>
								Protocol Parameters:
							</label>
						</h3>
						<div style="margin-top: 15px; display: flex; align-items: center; gap: 8px; margin-bottom: 6px;"
							class="nack-control-container">
							<!-- Added class -->

							<!-- Tooltip - First Item -->
							<div class="tooltip" style="flex-shrink: 0;"> <!-- Keep tooltip style -->
								<img src="../../info.svg" alt="Info icon" width="16" height="16">
								<span class="tooltiptext">If checked, the receiver will send a NACK when it receives an out-of-order
									packet. If unchecked, it will only send duplicate ACKs, relying solely on sender timeouts for
									recovery.</span>
							</div>

							<!-- Text Label wrapped in H3 - Second Item -->
							<h3 class="nack-label" style="margin-bottom: 2px;"> <!-- Added class to H3 -->
								Negative Acknowledgements
							</h3>

							<!-- Toggle Switch - Third Item -->
							<label class="toggle-switch small-switch" for="enableNacksCheckbox"> <!-- Keep small-switch class -->
								<input type="checkbox" id="enableNacksCheckbox" checked
									onchange="contr.setNackEnabledState(this.checked)">
								<span class="slider round"></span>
							</label>

						</div>
						<div class="dropdown" id="dropdownSW">
							<h3 class="dropbtn">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">Enter the window size of the sender. </span>
								</div>
								Sender Window
							</h3>
							<div class="dropdown-content">
							</div>
						</div>
						<input type="number" [disabled]="false" value="5" min="1" max="10" step="1" id="senderN"
							onchange="contr.setSenderN(this);" />


						<div class="dropdown" id="dropdownRW">
							<h3 class="dropbtn">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">Enter the window size of the receiver.</span>
								</div>
								Receiver Window
							</h3>
							<div class="dropdown-content">
							</div>
						</div>
						<input [disabled]="false" type="number" value="5" min="1" max="10" step="1" id="receiverN"
							onchange="contr.setReceiverN(this);" />


						<div class="dropdown" id="dropdownTO">
							<h3 class="dropbtn">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">Enter the timeout value. Please pay attention to the suggested minimum
										timeout. Otherwise there will be a lot of retransmissions.</span>
								</div>
								Timeout
							</h3>
							<div class="dropdown-content">
							</div>
						</div>

						<input type="number" value="60" min="2000" step="any" id="timeout" onchange="contr.setTimeout(this)" /><span
							id="unit">
							<select class="units" id="unitTimeout" onchange="contr.setTimeout(this);">
								<option value="1000">s</option>
								<option value="1" selected="selected">ms</option>
							</select>
					</div>

					<div class="form-item">
						<h3><label for="Link Parameters">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">This section is related to the parameters of the link between the sender and
										the receiver.</span>
								</div>
								Link Parameters:
							</label>
						</h3>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext">Enter the capacity of the link.</span>
							</div>
							Capacity
						</h3>
						<input type="number" value="1" min="0" step="any" id="Capacity" onchange="contr.setCapacity(this);" /><span
							id="unit">
							<select class="units" id="unitc" onchange="contr.setCapacity(this);">
								<option value="1">bit/s</option>
								<option value="1000" selected="selected">kbit/s</option>
								<option value="1000000">Mbit/s</option>
								<option value="1000000000">Gbit/s</option>
							</select>
						</span>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext">Enter the length of the link.</span>
							</div>
							Length
						</h3>
						<input type="number" value="1" id="Length" min="0" step="any" onchange="contr.setLength(this);" /><span
							id="unit">
							<select class="units" id="unitl" onchange="contr.setLength(this);">
								<option value="1">m</option>
								<option value="1000" selected="selected">km</option>
							</select>
						</span>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext">Enter the propagation speed.</span>
							</div>
							Propagation speed
						</h3>
						<input type="number" value="200000" min="0" step="any" id="Propagation"
							onchange="contr.setPropagation(this);" /><span id="unit">
							<select class="units" id="unitp" onchange="contr.setPropagation(this);">
								<option value="1">m/s</option>
								<option value="1000" selected="selected">km/s</option>
							</select>
						</span>
					</div>

					<div class="form-item">
						<h3><label for="Data Parameters">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext">This section is related to the parameters of data to be transmitted.</span>
								</div>
								Data Parameters:
							</label>
						</h3>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext">Enter the total amount of data to be transmitted.</span>
							</div>
							Amount of Data
						</h3>
						<input type="number" value="10" min="0" step="any" id="DataSize" onchange="contr.setDataSize(this);" /><span
							id="unit">
							<select class="units" id="unitd" onchange="contr.setDataSize(this);">
								<option value="1">bit</option>
								<option value="1000" selected="selected">kbit</option>
							</select>
						</span>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext">Enter the size of each packet.</span>
							</div>
							Packet Size
						</h3>
						<input type="number" value="500" min="0" step="1" id="UnitSize" onchange="contr.setUnitSize(this);" /><span
							id="unit">
							<select class="units" id="unitu" onchange="contr.setUnitSize(this);">
								<option value="1" selected="selected">bit</option>
								<option value="1000">kbit</option>
							</select>
						</span>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext">Enter the size of each acknowledgement unit.</span>
							</div>
							Acknowledgement Size
						</h3>
						<input type="number" value="20" min="0" step="1" id="AckSize" onchange="contr.setAckSize(this);" /><span
							id="unit">
							<select class="units" id="unita" onchange="contr.setAckSize(this);">
								<option value="1" selected="selected">bit</option>
								<option value="1000">kbit</option>
							</select>
						</span>
					</div>

					<div class="form-item">
						<h3><label for="Data Parameters">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext1">These parameters are calculated automaticly according to the inputs!</span>
								</div>
								Calculated Parameters:
							</label></h3>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext1">The transmission time of each packet is calculated according to the
									packet size and the link capacity.</span>
							</div>
							Packet Transmission Time
						</h3>
						<input type="number" value="500" step="any" id="TransmissionTime" disabled="disabled" /><span id="Consunit">
							<select class="unitdisabled" disabled id="unitTT">
								<option value="1000000">μs</option>
								<option value="1000" selected="selected">ms</option>
								<option value="1">s</option>
							</select>
						</span>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext1">The transmission time of each acknowledgement is calculated according to the
									acknowledgement size and
									the link capacity.</span>
							</div>
							Acknowledgement Transmission Time
						</h3>
						<input type="number" value="20" step="any" id="AckTT" disabled="disabled" /><span id="Consunit">
							<select class="unitdisabled" disabled id="unitAT">
								<option value="1000000">μs</option>
								<option value="1000" selected="selected">ms</option>
								<option value="1">s</option>
							</select>
						</span>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext1">The propagation delay is calculated according to the link length and the
									propagation speed.</span>
							</div>
							Propagation delay
						</h3>
						<input type="number" value="5" id="endToEndDelay2" disabled="disabled" /><span id="Consunit">
							<select class="unitdisabled" disabled id="unitPD">
								<option value="1000000" selected="selected">μs</option>
								<option value="1000">ms</option>
								<option value="1">s</option>
							</select>
						</span>
					</div>

					<div class="form-item">
						<h3><label for="Data Parameters">
								<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

									<span class="tooltiptext1">These parameters are calculated automaticly according to the inputs!</span>
								</div>
								Calculated Parameters:
							</label></h3>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext1">The number of information units is calculated according to the packet size
									and
									the total amount of data.</span>
							</div>
							Number of Packets
						</h3>
						<input type="number" value="20" min="0" step="1" id="NumberUI" disabled="disabled" />

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext1">The minimum timeout is suggested here according to the inputs. It depends on
									the propagation delay and the acknowldegement size.</span>
							</div>
							Minumun Timeout
						</h3>
						<input type="number" value="20.01" min="0" step="any" id="TimeoutMin" disabled="disabled" /><span
							id="Consunit">
							<select class="unitdisabled" disabled id="unitMT">
								<option value="1000000">μs</option>
								<option value="1000" selected="selected">ms</option>
								<option value="1">s</option>
							</select>
						</span>

						<h3>
							<div class="tooltip"><img src="../../info.svg" alt="Info icon" width="16" height="16">

								<span class="tooltiptext1">Total time will be calculated and showed here after the end of the animation.
									There might be a small variance in the order of microsecond because of the execution of the algorithm
									itself.</span>
							</div>
							Total Time
						</h3>

						<input type="number" value="" step="any" id="TotalTime" disabled="disabled" /><span id="Consunit">
							<select class="unitdisabled" disabled id="unitTotal">
								<option value="1000000">μs</option>
								<option value="1000" selected="selected">ms</option>
								<option value="1">s</option>
							</select>
						</span>
					</div>
				</form>
			</div>

			<!-- Legend Tab -->
			<div id="legend-tab" class="tab-content">
				<div class="legend">
					<h2>Legend</h2>
					<table>
						<tr>
							<td>
								<div class="dscPkg empty-legend">No data received yet</div>
							</td>
						</tr>
						<tr>
							<td>
								<div class="dscPkg"
									style="background-color: var(--packet-default-bg); color: var(--packet-default-text); border-color: var(--packet-default-border);">
									Buffered data</div>
							</td>
						</tr>
						<tr>
							<td>
								<div class="dscPkg"
									style="background-color: var(--packet-ack-bg); color: var(--packet-ack-text); border-color: var(--packet-ack-border);">
									ACK</div>
							</td>
						</tr>
						<tr>
							<td>
								<div id="nackleg" class="dscPkg"
									style="background-color: var(--packet-nack-bg); color: var(--packet-nack-text); border-color: var(--packet-nack-border);">
									NACK</div>
							</td>
						</tr>
						<tr>
							<td>
								<div class="dscPkg"
									style="background-color: var(--packet-confirmed-bg); color: var(--packet-confirmed-text); border-color: var(--packet-confirmed-border);">
									Transmission confirmed</div>
							</td>
						</tr>
						<tr>
							<td>
								<div class="dscPkg"
									style="background-color: var(--packet-delivered-bg); color: var(--packet-delivered-text); border-color: var(--packet-delivered-border);">
									Data has been delivered to upper network layer</div>
							</td>
						</tr>
					</table>
				</div>
			</div>
		</aside>

		<!-- Toggle Button for Sidebar -->
		<button id="sidebar-toggle" title="Toggle Sidebar">×</button>

		<!-- Main Content with Simulation -->
		<main id="main-content">
			<div id="svg" class="simulation">
				<hr class="lineSender">
				</hr>
				<hr class="lineReciever">
				</hr>
				<div id="root"></div>
			</div>

			<div id="log"
				style="position: relative; overflow: auto; width: 100%; height: 280px; display: block; margin-top: 10px; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; background: white;">
				<p id="myLog">Log: </p>
			</div>
		</main>
	</div>
</body>

</html>